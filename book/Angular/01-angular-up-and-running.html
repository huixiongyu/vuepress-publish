<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Angular即学即用 | 灰熊の博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/flower.ico">
    <meta name="description" content="进击的全栈Coder">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.5be59e6d.js" as="script"><link rel="preload" href="/assets/js/2.9b8ab7f9.js" as="script"><link rel="preload" href="/assets/js/24.7b9f29fc.js" as="script"><link rel="prefetch" href="/assets/js/10.0cc0fbc4.js"><link rel="prefetch" href="/assets/js/11.5ceb0271.js"><link rel="prefetch" href="/assets/js/12.b0957377.js"><link rel="prefetch" href="/assets/js/13.3860ef69.js"><link rel="prefetch" href="/assets/js/14.c0ad0105.js"><link rel="prefetch" href="/assets/js/15.2708bd90.js"><link rel="prefetch" href="/assets/js/16.61bc46ea.js"><link rel="prefetch" href="/assets/js/17.80d5fd2b.js"><link rel="prefetch" href="/assets/js/18.24b34451.js"><link rel="prefetch" href="/assets/js/19.a6a5c7f3.js"><link rel="prefetch" href="/assets/js/20.bc29734e.js"><link rel="prefetch" href="/assets/js/21.372cf30f.js"><link rel="prefetch" href="/assets/js/22.2bb526bc.js"><link rel="prefetch" href="/assets/js/23.2c6cf222.js"><link rel="prefetch" href="/assets/js/25.cd4e4275.js"><link rel="prefetch" href="/assets/js/26.28554fbe.js"><link rel="prefetch" href="/assets/js/27.069a7872.js"><link rel="prefetch" href="/assets/js/28.021870a3.js"><link rel="prefetch" href="/assets/js/29.3a2ed301.js"><link rel="prefetch" href="/assets/js/3.66297c97.js"><link rel="prefetch" href="/assets/js/30.ced36822.js"><link rel="prefetch" href="/assets/js/31.3cac6451.js"><link rel="prefetch" href="/assets/js/32.57a49a15.js"><link rel="prefetch" href="/assets/js/33.5a0a97f0.js"><link rel="prefetch" href="/assets/js/34.73d9a29a.js"><link rel="prefetch" href="/assets/js/35.d9007735.js"><link rel="prefetch" href="/assets/js/36.bb1d44a2.js"><link rel="prefetch" href="/assets/js/37.ffbfd887.js"><link rel="prefetch" href="/assets/js/38.38f22f62.js"><link rel="prefetch" href="/assets/js/39.bf740825.js"><link rel="prefetch" href="/assets/js/4.55eb244d.js"><link rel="prefetch" href="/assets/js/40.93994d70.js"><link rel="prefetch" href="/assets/js/41.a28cf76a.js"><link rel="prefetch" href="/assets/js/42.7e9f1055.js"><link rel="prefetch" href="/assets/js/43.44403f17.js"><link rel="prefetch" href="/assets/js/44.6e610e79.js"><link rel="prefetch" href="/assets/js/45.36f736c0.js"><link rel="prefetch" href="/assets/js/46.4c804fc0.js"><link rel="prefetch" href="/assets/js/47.0667717c.js"><link rel="prefetch" href="/assets/js/48.e83b8743.js"><link rel="prefetch" href="/assets/js/49.ceba609e.js"><link rel="prefetch" href="/assets/js/5.7d12f753.js"><link rel="prefetch" href="/assets/js/50.a7ffbd44.js"><link rel="prefetch" href="/assets/js/51.9191de05.js"><link rel="prefetch" href="/assets/js/52.df288a38.js"><link rel="prefetch" href="/assets/js/53.517e274d.js"><link rel="prefetch" href="/assets/js/54.6c1987aa.js"><link rel="prefetch" href="/assets/js/55.fde40f5c.js"><link rel="prefetch" href="/assets/js/56.2da5bda2.js"><link rel="prefetch" href="/assets/js/57.566b4173.js"><link rel="prefetch" href="/assets/js/58.92e8b5dd.js"><link rel="prefetch" href="/assets/js/59.274514da.js"><link rel="prefetch" href="/assets/js/6.44237979.js"><link rel="prefetch" href="/assets/js/60.925087fc.js"><link rel="prefetch" href="/assets/js/61.f7875652.js"><link rel="prefetch" href="/assets/js/62.0663dca9.js"><link rel="prefetch" href="/assets/js/63.8e8b3e99.js"><link rel="prefetch" href="/assets/js/64.6799aa84.js"><link rel="prefetch" href="/assets/js/65.9ffed0c4.js"><link rel="prefetch" href="/assets/js/66.58e13a1a.js"><link rel="prefetch" href="/assets/js/67.5b728462.js"><link rel="prefetch" href="/assets/js/68.fffb4505.js"><link rel="prefetch" href="/assets/js/69.411058b6.js"><link rel="prefetch" href="/assets/js/7.12041889.js"><link rel="prefetch" href="/assets/js/70.316f37fd.js"><link rel="prefetch" href="/assets/js/71.7b1e8e79.js"><link rel="prefetch" href="/assets/js/72.44e79d39.js"><link rel="prefetch" href="/assets/js/73.8eeca473.js"><link rel="prefetch" href="/assets/js/74.0bb53483.js"><link rel="prefetch" href="/assets/js/75.c600e42f.js"><link rel="prefetch" href="/assets/js/76.08c8db66.js"><link rel="prefetch" href="/assets/js/77.5c3f11fa.js"><link rel="prefetch" href="/assets/js/78.bf1850e3.js"><link rel="prefetch" href="/assets/js/79.65f52781.js"><link rel="prefetch" href="/assets/js/8.19fb772b.js"><link rel="prefetch" href="/assets/js/80.346e5607.js"><link rel="prefetch" href="/assets/js/81.fa378849.js"><link rel="prefetch" href="/assets/js/82.917282bb.js"><link rel="prefetch" href="/assets/js/83.ab30e9c6.js"><link rel="prefetch" href="/assets/js/84.ffa19f6c.js"><link rel="prefetch" href="/assets/js/85.75e68c80.js"><link rel="prefetch" href="/assets/js/9.85c18bde.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">灰熊の博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/huixiongyu/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/huixiongyu/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/book/" aria-current="page" class="sidebar-link">阅读</a></li><li><a href="/book/plan-and-record.html" class="sidebar-link">阅读统计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/plan-and-record.html#_2021年已读" class="sidebar-link">2021年已读</a></li><li class="sidebar-sub-header"><a href="/book/plan-and-record.html#_2020已读" class="sidebar-link">2020已读</a></li></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Angular</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/Angular/01-angular-up-and-running.html" aria-current="page" class="active sidebar-link">Angular即学即用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第2章-你好-angular" class="sidebar-link">第2章：你好！Angular</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第3章-使用angular内置指令" class="sidebar-link">第3章：使用Angular内置指令</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第4章-理解和使用angular组件" class="sidebar-link">第4章：理解和使用Angular组件</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第5章-测试angular组件" class="sidebar-link">第5章：测试Angular组件</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第6章-使用模板驱动表单" class="sidebar-link">第6章：使用模板驱动表单</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第7章-使用响应式表单" class="sidebar-link">第7章：使用响应式表单</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第8章-angular服务" class="sidebar-link">第8章：Angular服务</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第9章-angular与http请求" class="sidebar-link">第9章：Angular与HTTP请求</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第10章-对服务器进行单元测试" class="sidebar-link">第10章：对服务器进行单元测试</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第11章-路由" class="sidebar-link">第11章：路由</a></li><li class="sidebar-sub-header"><a href="/book/Angular/01-angular-up-and-running.html#第12章-部署到生产" class="sidebar-link">第12章：部署到生产</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>沟通</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="angular即学即用"><a href="#angular即学即用" class="header-anchor">#</a> Angular即学即用</h1> <p>项目地址：<a href="https://github.com/shyamseshadri/angular-up-and-running" target="_blank" rel="noopener noreferrer">link<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
官方API文档：<a href="https://angular.io/api" target="_blank" rel="noopener noreferrer">API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
官方快速入门：<a href="https://angular.io/start" target="_blank" rel="noopener noreferrer">start<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://angular.io/tutorial" target="_blank" rel="noopener noreferrer">Angular Heroes<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="第2章-你好-angular"><a href="#第2章-你好-angular" class="header-anchor">#</a> 第2章：你好！Angular</h2> <p>初始化</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install -g typescript
npm install -g @angular/cli
ng --vesion
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank" rel="noopener noreferrer">TypeScript装饰器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
declarations: declarations块定义了在这个模块中允许在HTML范围内使用的所有组件。你所创建的任何组件都必须在使用之前进行声明
imports：imports数组允许导入其他的Angular应用程序和库模块，从而利用这些模块中已经创建好的组件、服务和其他功能。
bootstrap：bootstrap数组定义充当应用程序入口点的组件。</p> <p><strong>一个Angular组件只不过是一个TypeScript类，可以用一些属性和元数据修饰的类。该类封装了组件的所有数据和功能，而装饰器则指定了如何将其转换为HTML。</strong></p> <ul><li>app-selector是一个CSS选择器，它用于定义在一个HTML页面中如何找到特定的组件</li> <li>templateUrl是用于呈现该组件的HTML的路径。</li> <li>styleUrls是模板的样式，封装了该组件的所有样式。与templateUrl不同，styleUrls是一个数组。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>ng generate component stock/stock-item
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>[]是语法可以用于元素的任何属性，它是一种从组件到UI的单向绑定。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[class]=&quot;positiveChange ? 'positive' : 'negative'&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Angular数据绑定只能用于DOM属性，而不能用于HTML属性。HTML属性通常用于DOM元素的初始化，但在此之后，它们对底层元素就没有任何影响了。一旦元素初始化之后，它的行为就会由DOM属性来控制。
换句话说，HTML属性用于设置HTML DOM元素的初始值，但在此之后，它的行为由DOM属性来驱动。</p> <p><strong>事件绑定</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(click)=&quot;toggleFavorite()&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这种语法被称为Angular事件绑定。</p> <p>优化：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ng generate class model/stock
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="第3章-使用angular内置指令"><a href="#第3章-使用angular内置指令" class="header-anchor">#</a> 第3章：使用Angular内置指令</h2> <p>ngClass绑定多个CSS class类：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[ngClass]=&quot;stockClasses&quot;

// ts
ngOnInit(): void {
    this.stock = new Stock('Test Stock Company', 'TSC', 85, 80);
    let diff = (this.stock.price / this.stock.previousPrice) - 1;
    let largeChange = Math.abs(diff) &gt; 0.01;
    this.stockClasses = {
      &quot;positive&quot;: this.stock.isPositiveChange(),
      &quot;negative&quot;: !this.stock.isPositiveChange(),
      &quot;large-change&quot;: largeChange,
      &quot;small-change&quot;: !largeChange
    }
  }


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>ngStyle实现相同的效果：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[ngStyle]=&quot;stockStyles&quot;

// ts
this.stockStyles = {
	&quot;color&quot;: 
.stock.isPositiveChange() ? &quot;green&quot;: &quot;red&quot;,
	&quot;font-size&quot;: largeChange ? &quot;1.2em&quot;: &quot;0.8em&quot;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>逐个类名或者样式的绑定：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[class.positive]=&quot;stock.isPositiveChange()&quot;
[class.
]=&quot;!stock.isPositiveChange()&quot;

[style.background-color]=&quot;stock.isPositiveChange() ? 'green' : 'red'&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>但是，如果涉及的class不止一两个的时候，最好用NgClass指令，因为它更容易管理和测试。</strong></p> <p><strong>内置结构化指令</strong></p> <p><a href="https://angular.io/guide/attribute-directives" target="_blank" rel="noopener noreferrer">Attribute directives<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>所有的结构化指令都是用星号（*）开头的。
NgIf指令允许你在UI中有条件地隐藏或显示元素。</p> <p>而NgFor指令用于创建多个元素，通常会为一个数组中的每个实例单独创建一个。
从技术上讲，*ngFor指令使用的是底层的NgForOf这个类。</p> <p>在浏览器中，元素创建或删除是两个代价高昂的操作。</p> <p>我们只需要修改了*ngFor,在这个微语法中传递一个额外的属性，即trackBy:trackStockByCode。这将确保Angular调用这个函数而不是使用object reference来识别每个item。
这确保了即使我们重新加载服务器的所有股票（这会改变所有的object reference），Angular仍然会通过查看股票代码来决定是否重用DOM中的元素。</p> <p>NgSwitch本身并不是一个结构指令，而是一个属性指令。
NgSwitchCase和NgSwitchDefault才是真正的结构指令。</p> <h2 id="第4章-理解和使用angular组件"><a href="#第4章-理解和使用angular组件" class="header-anchor">#</a> 第4章：理解和使用Angular组件</h2> <p>在组件中只能指定template和templateUrl两者之一。你不能同时使用两者，但必须至少有一个。</p> <p><strong>样式封装：</strong></p> <ul><li>ViewEncapsulation.Emulated： 这是默认值，Angular会创建模拟影子DOM和影子root行为的胶水代码。</li> <li>ViewEncapsulation.Native：这是理想情况，Angular会使用影子root。这只适用本来就支持它的浏览器和平台。</li> <li>ViewEncapsulation.None：使用全局CSS，没有任何封装。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  encapsulation: ViewEncapsulation.None
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>变化检测：</p> <p>当需要更新UI时，我们可能想显式地告诉Angular什么时候更新UI，而不是让Angular自己决定更新UI的时机。为了实现这一点，我们需要用changeDetection属性，将默认的Detection Strategy.Default修改为C hangeDetectionStrategy.OnPush。</p> <p>组件和模块：</p> <p>对于在模块上下文中使用的任何组件，必须将其倒入到模块声明文件中，并在declarations数组中进行声明。这确保了组件对模块中的其它组件是可见的。</p> <p>declarations属性确保组件和指令可以在模块的范围内使用。</p> <p>如果你有多个模块，或者你要创建一个供其他开发人员使用的库，那么就要用到exports属性了。</p> <p>输入：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 子组件
@Input() public stock: Stock;

// 父组件
export class AppComponent implements OnInit {
	title = 'Stock Market App';
	public stockObj: Stock;
	
	ngOnInit(): void {
		this.stockObj = new Stock('Test Stock Company', 'TSC', 85, 80);
	}
}

&lt;app-stock-item [stock]=&quot;stockObj&quot;&gt;&lt;/app-stock-item&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>输出：子组件定义的@Output() 名作为一个事件去绑定</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 子组件
&lt;button (click)=&quot;onToggleFavorite($event)&quot;
          *ngIf=&quot;!stock.favorite&quot;&gt;Add to Favorite&lt;/button&gt;
          
export class StockItemComponent {

  @Input() public stock: Stock;
  @Output() private toggleFavorite: EventEmitter&lt;Stock&gt;;

  constructor() {
    this.toggleFavorite = new EventEmitter&lt;Stock&gt;();
   }

  onToggleFavorite(event) {
    this.toggleFavorite.emit(this.stock);
  }
}

// 父组件
&lt;app-stock-item [stock]=&quot;stock&quot;
                (toggleFavorite)=&quot;onToggleFavorite($event)&quot;&gt;&lt;/app-stock-item&gt;
                
onToggleFavorite(stock: Stock) {
    console.log('Favorite for stock ', stock, ' was triggered');
    this.stock.favorite = !this.stock.favorite;
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>生命周期：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>constructor
ngOnChanges
ngOnInit
ngDoCheck
	ngAfterCoontentInit
	ngAfterContentChecked
	ngAfterViewInit
	ngAfterViewChecked
ngOnDestroy
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>因此，父子组件生命周期出发过程：</p> <ul><li>On Init</li> <li>Do Check</li> <li>After Content Init</li> <li>After Content Checked
<ul><li>On Init</li> <li>Do Check</li> <li>After Content Init</li> <li>After Content Checked</li> <li>After View Init</li> <li>After View Checked</li></ul></li> <li>After View Init</li> <li>AFter View Checked</li></ul> <p>内容投影深入介绍：<a href="https://medium.com/claritydesignsystem/ng-content-the-hidden-docs-96a29d70d11b" target="_blank" rel="noopener noreferrer">《ng-content: The hidden docs》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="第5章-测试angular组件"><a href="#第5章-测试angular组件" class="header-anchor">#</a> 第5章：测试Angular组件</h2> <p>如果Jasmine事测试编写框架，那么Karma就是测试运行框架。Karma的唯一任务是进行任何类型的测试，并通过一系列真实浏览器运行它并报告结果。它高度关注开发工作流，因为它主要面向的是快速执行和报告。</p> <p><a href="https://angular.io/guide/testing" target="_blank" rel="noopener noreferrer">Angular Testing<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>describe('AppComponent', () =&gt; {

  describe('Simple, No Angular Unit Test', () =&gt; {
    it('should have stock instantiated on ngInit', () =&gt; {
      const appComponent = new AppComponent();
      expect(appComponent.stock).toBeUndefined();
      appComponent.ngOnInit();
      expect(appComponent.stock).toEqual(
        new Stock('Test Stock Company', 'TSC', 85, 80));
    });

    it('should have toggle stock favorite', () =&gt; {
      const appComponent = new AppComponent();
      appComponent.ngOnInit();
      expect(appComponent.stock.favorite).toBeFalsy();
      appComponent.onToggleFavorite(new Stock('Test', 'TEST', 54, 55));
      expect(appComponent.stock.favorite).toBeTruthy();
      appComponent.onToggleFavorite(new Stock('Test', 'TEST', 54, 55));
      expect(appComponent.stock.favorite).toBeFalsy();
    });
  });
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>注意，在隔离单元测试中，Angular生命周期方法不是自动调用的，这就是为什么我们在测试中手动调用ngOnInit的原因。</p> <p><a href="https://jasmine.github.io/api/2.8/matchers.html" target="_blank" rel="noopener noreferrer">jasmine matchers<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>非异步的beforeEach, 在上一个beforeEach之后执行。</p> <p>在这个beforeEach中，我们调用fixture.detectChanges()。这是一个给Angular的信号，触发它的变化检测机制，它会查看组件中的值并更新相应HTML中的绑定。它也是组件第一次执行ngOnInit的触发器。如果没有这个，组件的HTML就不会有任何值。</p> <p><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints" target="_blank" rel="noopener noreferrer">Chrome DevTools使用断点调试代码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>忘记调用fixture.detectChanges()是编写Angular测试时最常见的错误之一。默认情况下，它是手动调用的，因此当用户交互或服务器响应的事件发生时，它由开发人员触发。</p> <h2 id="第6章-使用模板驱动表单"><a href="#第6章-使用模板驱动表单" class="header-anchor">#</a> 第6章：使用模板驱动表单</h2> <p>我们向input表单元素添加了一个name字段。这对于ngModel指令的使用是必需的。</p> <p>我们添加的第二个绑定是ngModelChange事件绑定。在这里，我们用$event的值更新底层组件的成员变量(stock.name), $event是文本表单字段的变化值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot;
	placeholder=&quot;Stock name&quot;
	name=&quot;stockName&quot;
	[ngModel]=&quot;stock.name&quot;
	(ngModelChange)=&quot;stock.name=$event&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>有一个更简单的版本，即我们用得最多的[(ngModel)]香蕉语法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot;
	placeholder=&quot;Stock name&quot;
	name=&quot;stockName&quot;
	[(ngModel)]=&quot;stock.name&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>模板引用变量：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot; #myStockField name=&quot;stockName&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>直接通过myStockField.value访问它的值，然后将其作为参数传递给函数。</p> <h2 id="第7章-使用响应式表单"><a href="#第7章-使用响应式表单" class="header-anchor">#</a> 第7章：使用响应式表单</h2> <p>响应式表单的核心是FormControl，它直接表示模板中的单个form元素。因此，任何响应式表单都只是一系列分组的FormControl。在FormControl级别，我们还会指定初始值和验证器（同步和异步）。</p> <p>当我们需要跟踪任何单个表单元素（比如输入框或复选框）的状态和值时，就可以使用FormContrl。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public stockForm: FormGroup = new FormGroup({
  name: new FormControl(null, Validators.required),
  code: new FormControl(null, [Validators.required, Validators.minLength(2)]),
  price: new FormContrl(0, [Validators.required, Validators.min(0)])
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>官方内置的<a href="https://angular.io/api/forms/Validators" target="_blank" rel="noopener noreferrer">validator<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>FormBuilder本质上是一种语法糖，允许我们快速创建表单组和表单控件元素，而不需要手动地去new每个元素。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public stockForm: FormGroup;
constructor(private fb: FormBuilder) {
  this.createForm();
}
createForm() {
  this.stockForm = this.fb.group({
    name: [null, Validators.required],
    code: [null, [Validators.required, Validators.minLength(2)]],
    price: [0, [Validators.required, Validators.min(0)]]
  })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>表单中获取值：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export class CreateStockComponent {
  get name() { return this.stockForm.get('name'); }
  get price() { return this.stockForm.get('price'); }
  get code() { return this.stockForm.get('code'); }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="第8章-angular服务"><a href="#第8章-angular服务" class="header-anchor">#</a> 第8章：Angular服务</h2> <p>在一个Angular App中，实际数据的获取和公共业务逻辑应该由谁来负责？这就用到了Angular服务。Angular服务通常会是跨过APP的一层，它可以跨过各种组件重用。
创建服务的用途：</p> <ul><li>向服务器获取数据或发送数据</li> <li>需要封装不特定于任何组件或者可以跨组件重用的应用的应用程序逻辑</li> <li>需要跨组件共享数据，尤其是这些组件彼此互不知道的时候。</li></ul> <p>服务它是从组件中抽象出来的关于“怎么做”的一层，以便组件专注于”做什么“，而服务则决定了”怎么做“。</p> <p>在Angular模块中的providers数组是告诉Angular去创建服务的单例，并使其对任何需要它的类或组件可用。当我们在模块级别注册它时，意味着模块中的任何需要它的组件都会被注入同一个相同的实例。</p> <p>依赖注入时在静态语言中出现的，这些语言常见于服务器端编程。简单地说，依赖注入是指某个类或函数会需要一个不是自己实例化的依赖对象。由其他对象（通常称为注入器）来负责提供这个对象及实例化这个对象。</p> <p><a href="https://angular.io/guide/dependency-injection" target="_blank" rel="noopener noreferrer">dependency-injection<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>两种实例化：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class MyDummyService {
	getMyData() {
		let httpService = new HttpService();
		return httpService.get('my/api');
	}
}

class MyDIService {
	constructor(private httpService: HttpService) {}
	getMyData() {
		return this.httpService.get('my/api');
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>对于很简单的需求，将Angular的依赖注入服务看作一个非常简单的键值存储就足够了，任何组件或类在初始化时都可以向它请求一个key。</p> <p>我们创建的每一个服务都需要向注入器注册一个提供者。然后，任何其他类都可以请求服务，而注入器将负责提供服务。</p> <p>请注意，我们将messageService设置为public的，这样就可以在模板中访问它了。我们确认只有一个MessageService实例存在，它在两个组件之间共享。</p> <p>当组件请求依赖时，Angular就会检查注入器树中距离最近的注入器，看它是否匹配。如果匹配，就用它来提供。如果没有，就检查父注入器，一直到根注入器。</p> <p><strong>RxJS和Observables：使用异步操作</strong></p> <p>Promise比起回掉来说，是一种更好的、惯用的处理一步行为的方法。同时，Angular为了避免它的一些缺陷，用Observable代替了它。</p> <ul><li>Promise是对单个异步事件的操作，而Observable允许我们处理零个或多个异步事件流。</li> <li>与Promise不同，Observ able可以被取消。也就是说，Promise无论执行成功还是出错handler都会最终被调用，而Observable不同，如果我们不再关心它时，我们就可以取消订阅，同时不再处理数据。</li> <li>Observable使我们能够很容易地组合和创建一个转换链。</li></ul> <p><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener noreferrer">ReactiveX官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>getStocks(): Observable&lt;Stock[]&gt; {
	return ObservableOf(this.stocks);
}

// 使用者订阅
ngOnInit() {
	this.stockService.getStocks()
		.subscribe(stocks =&gt; {
			this.stocks = stocks;
		})
}
createStock(stockForm) {
	if(stockForm.valid) {
		this.stockService.createStock(this.stock)
			.subscribe((result: any) =&gt; {
				this.message = result.msg;
				this.stock = new Stock('', '', 0, 0, 'NASDAQ');
			}, (err) =&gt; {
				this.message = err.msg;
			})
	} else {
		console.error('Stock form is in an invalid state');
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>模板处理异步行为：</p> <p>ngFor表达式中使用了管道操作。Angular提供了一个async管道，它允许我们绑定Observable。然后，Angular就会负责等待Observable发送事件，再直接将结果显示出来。它为我们省去了手动订阅Observable的那一步。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export class StockListComponent implements OnInit {
	public stocks$: Observable&lt;Stock[]&gt;;
	constructor(private stockService: StockService){}
	ngOnInit() {
		this.stocks$ = this.stockService.getStocks();
	}
	onToggleFavorite(stock: Stock) {
		this.stockService.toggleFavorite(stock);
	}
}

// 模板的使用
&lt;app-stock-item *ngFor=&quot;let stock of stocks$ | async&quot;
	[stock]=&quot;stock&quot;
	(toggleFavorite)=&quot;onToggleFavorite($event)&quot;&gt;
&lt;/app-stock-item&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="第9章-angular与http请求"><a href="#第9章-angular与http请求" class="header-anchor">#</a> 第9章：Angular与HTTP请求</h2> <p>首先我们需要在App Module中添加对HttpClientModule的依赖。将src/app/app.module.ts的文件导入HttpClientModule，而不是HttpModule。</p> <p>在需要用到请求的文件中导入HttpClient</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import { HttpClientModule } from '@angular/common/http';

import { HttpClient } from '@angular/common/http';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>跨域问题，Angular App根文件下创建一个proxy.conf.json文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
	&quot;/api&quot;: {
		&quot;target&quot;: &quot;http://localhost:3000&quot;,
		&quot;secure&quot;: false
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>理解HttpInterceptor的一个关键是它的链式结构。在请求时会都可以决定是否要修改请求。它可以通过使用调用HttpHandler继续将请求传递给后续链。如果只有一个拦截器，那么handler将简单地将请求对象发送给后端。如果有更多的拦截器，则传递给链中的下一个拦截器。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>providers: [
	StockService,
	AuthService,
	{
		provide: HTTP_INTERCEPTIORS,
		useClass: StockAppInterceptor,
		multi: true,
	}
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>HttpRequest和HttpResponse实例都是不可变的。因此，我们需要修改它们，必须创建新的不可变实例。</p> <p><strong>Observable进阶</strong></p> <p>从根本上说，一个Observable只是一个连接生产者和消费者的函数。冷信号会创建生产者，而热信号则是共享生产者的。</p> <p>如果有人订阅了一个Angular Observable，就会为这个对象创建出生产者。这就是为什么每次订阅，我们都会有一个新的生产者。</p> <p><a href="https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339" target="_blank" rel="noopener noreferrer">Hot vs Code Observables<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>在App中使用AsyncPipe是要注意，如果在同一个Observable上使用多个异步管道而不是共享底层Observable时，会导致重复的服务器调用。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ngOnInit() {
	this.stocks$ = this.searchTerms.pipe(
		starWith(this.searchString),
		debounceTime(500),
		distinctUntilChanged(),
		switchMap((query) =&gt; this.stockService.getStocks(query)),
		share()
        );
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>为了形成链，我们在Observable上使用了pipe操作符，然后就可以向管道函数添加任意数量的以参数形式构成的操作符。</p> <p>Observable操作符distinctUntilChanged()。这可以确保仅当新值与前一个值不同时才发出事件，从而节省更多的网络调用。</p> <p>switchMap有一个好处，除了可以将一种Observable转换为另一种Observable之外，它还能够取消旧的、正在运行的订阅。</p> <p>操作符参考：<a href="http://reactivex.io/rxjs/manual/overview.html#operators" target="_blank" rel="noopener noreferrer">rxjs operators<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="第10章-对服务器进行单元测试"><a href="#第10章-对服务器进行单元测试" class="header-anchor">#</a> 第10章：对服务器进行单元测试</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>describe('StockService', () =&gt; {
	beforeEach(() =&gt; {
		TestBed.configureTestingModule({
			providers: [StockService]
		});
	});
	
	it('should be created', inject([StockService],
		(service: StockService) =&gt; {
		expect(service).toBeTruthy();
		}))
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在it块中是真正的测试，我们不算是只传递测试函数传递给它，我们调用了inject，它是Angular测试工具提供的一个函数。我们在第一个参数中传递一个数组，即需要注入到测试中的Angular服务。第二个参数是一个函数，它获取参数的顺序与我们传递给数组的顺序相同，在这个函数中编写实际的测试。</p> <p><strong>模拟服务测试组件：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>beforeEach(() =&gt; {
	fixture = TestBed.createComponent(StockListComponent);
	component = fixture.componentInstance;
	// 通过注入方式获取服务
	stockService = fixture.debugElement.injector.get(StockService);
	let spy = spyOn(stockService, 'getStocks')
		.and.returnValue([
			new Stock('Mock Stock', 'MS', 800, 900, 'NYSE')
		]);
	fixture.detectChanges();
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>一旦我们获得服务对象，我们就可以使用Jasmine 的spy来监听服务商的不同方法。Spy（无论是来自Jasmine还是其他框架）允许我们对任何函数或方法进行代理，记录它的调用和参数，也可以指定我们自己的返回值。</p> <p><strong>用假服务测试组件：</strong></p> <p>如果你有一个重复的测试用例，那么创建一个可以重用的假服务也是可以的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>TestBed.configureTestingModule({
	declarations: [ StockListComponent, StockItemComponent ],
	providers: [{
		provide: StockService,
		useValue: stockServiceFake
	}]
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>我们告诉Angular，每当有人请求StockService(用provide指定)时，就提供stockServiceFake（由useValue指定）给它。这会覆盖类实例的默认提供行为。</p> <p>获取服务对象（即使是假服务）的推荐方法是通过注入器。这是因为我们在测试中创建的fakeStockService对象和Angular用依赖注入提供的对象是不一样的。</p> <p><strong>异步单元测试：</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>fixture.whenStable().then(() =&gt; {
	fixture.detectChanges();
	expect(component.message)
		.toEqual(&quot;Tock with code MNTS successfully created&quot;);
	const messageEl = fixture.debugElement.query(
		By.css('.message')).nativeElement;
	expect(messageEl.textContent)
		.toBe('Stock with code MNTS successfully created');
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>在异步测试中，使用whenStable总错不了。</strong></p> <p>我们用fakseAsync函数取代了whenStable函数，现在用一个简单的tick()函数完成同样的工作。这样代码看起来更“线性”一些，可读性更好。</p> <p>在假异步测试中，实际有两个方法可以模拟时间的流逝，分别是tick()和flush()。tick模拟经过了一段时间（可以传递一个毫秒数的参数给它）。flush则使用次数作为参数，次数表示任务队列被完成过多少次。</p> <p>httpBackend.expectOne还支持用一个HttpRequest对象作为一个config对象，来代替URL参数和method参数。</p> <h2 id="第11章-路由"><a href="#第11章-路由" class="header-anchor">#</a> 第11章：路由</h2> <p>测试</p> <h2 id="第12章-部署到生产"><a href="#第12章-部署到生产" class="header-anchor">#</a> 第12章：部署到生产</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">12/15/2021, 3:52:44 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book/React/03-React-Native-develop-practice.html" class="prev">
        《React Native移动开发实战》
      </a></span> <span class="next"><a href="/book/Mini/01-mini-program-practice.html">
        《微信小程序项目开发实战：用WePY、mpvue、Taro打造高效的小程序》
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5be59e6d.js" defer></script><script src="/assets/js/2.9b8ab7f9.js" defer></script><script src="/assets/js/24.7b9f29fc.js" defer></script>
  </body>
</html>
