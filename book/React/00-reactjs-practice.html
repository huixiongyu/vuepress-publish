<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《React.js实战》 | 灰熊の博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/flower.ico">
    <meta name="description" content="进击的全栈Coder">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.5be59e6d.js" as="script"><link rel="preload" href="/assets/js/2.9b8ab7f9.js" as="script"><link rel="preload" href="/assets/js/45.36f736c0.js" as="script"><link rel="prefetch" href="/assets/js/10.0cc0fbc4.js"><link rel="prefetch" href="/assets/js/11.5ceb0271.js"><link rel="prefetch" href="/assets/js/12.b0957377.js"><link rel="prefetch" href="/assets/js/13.3860ef69.js"><link rel="prefetch" href="/assets/js/14.c0ad0105.js"><link rel="prefetch" href="/assets/js/15.2708bd90.js"><link rel="prefetch" href="/assets/js/16.61bc46ea.js"><link rel="prefetch" href="/assets/js/17.80d5fd2b.js"><link rel="prefetch" href="/assets/js/18.24b34451.js"><link rel="prefetch" href="/assets/js/19.a6a5c7f3.js"><link rel="prefetch" href="/assets/js/20.bc29734e.js"><link rel="prefetch" href="/assets/js/21.372cf30f.js"><link rel="prefetch" href="/assets/js/22.2bb526bc.js"><link rel="prefetch" href="/assets/js/23.2c6cf222.js"><link rel="prefetch" href="/assets/js/24.7b9f29fc.js"><link rel="prefetch" href="/assets/js/25.cd4e4275.js"><link rel="prefetch" href="/assets/js/26.28554fbe.js"><link rel="prefetch" href="/assets/js/27.069a7872.js"><link rel="prefetch" href="/assets/js/28.021870a3.js"><link rel="prefetch" href="/assets/js/29.3a2ed301.js"><link rel="prefetch" href="/assets/js/3.66297c97.js"><link rel="prefetch" href="/assets/js/30.ced36822.js"><link rel="prefetch" href="/assets/js/31.3cac6451.js"><link rel="prefetch" href="/assets/js/32.57a49a15.js"><link rel="prefetch" href="/assets/js/33.5a0a97f0.js"><link rel="prefetch" href="/assets/js/34.73d9a29a.js"><link rel="prefetch" href="/assets/js/35.d9007735.js"><link rel="prefetch" href="/assets/js/36.bb1d44a2.js"><link rel="prefetch" href="/assets/js/37.ffbfd887.js"><link rel="prefetch" href="/assets/js/38.38f22f62.js"><link rel="prefetch" href="/assets/js/39.bf740825.js"><link rel="prefetch" href="/assets/js/4.55eb244d.js"><link rel="prefetch" href="/assets/js/40.93994d70.js"><link rel="prefetch" href="/assets/js/41.a28cf76a.js"><link rel="prefetch" href="/assets/js/42.7e9f1055.js"><link rel="prefetch" href="/assets/js/43.44403f17.js"><link rel="prefetch" href="/assets/js/44.6e610e79.js"><link rel="prefetch" href="/assets/js/46.4c804fc0.js"><link rel="prefetch" href="/assets/js/47.0667717c.js"><link rel="prefetch" href="/assets/js/48.e83b8743.js"><link rel="prefetch" href="/assets/js/49.ceba609e.js"><link rel="prefetch" href="/assets/js/5.7d12f753.js"><link rel="prefetch" href="/assets/js/50.a7ffbd44.js"><link rel="prefetch" href="/assets/js/51.9191de05.js"><link rel="prefetch" href="/assets/js/52.df288a38.js"><link rel="prefetch" href="/assets/js/53.517e274d.js"><link rel="prefetch" href="/assets/js/54.6c1987aa.js"><link rel="prefetch" href="/assets/js/55.fde40f5c.js"><link rel="prefetch" href="/assets/js/56.2da5bda2.js"><link rel="prefetch" href="/assets/js/57.566b4173.js"><link rel="prefetch" href="/assets/js/58.92e8b5dd.js"><link rel="prefetch" href="/assets/js/59.274514da.js"><link rel="prefetch" href="/assets/js/6.44237979.js"><link rel="prefetch" href="/assets/js/60.925087fc.js"><link rel="prefetch" href="/assets/js/61.f7875652.js"><link rel="prefetch" href="/assets/js/62.0663dca9.js"><link rel="prefetch" href="/assets/js/63.8e8b3e99.js"><link rel="prefetch" href="/assets/js/64.6799aa84.js"><link rel="prefetch" href="/assets/js/65.9ffed0c4.js"><link rel="prefetch" href="/assets/js/66.58e13a1a.js"><link rel="prefetch" href="/assets/js/67.5b728462.js"><link rel="prefetch" href="/assets/js/68.fffb4505.js"><link rel="prefetch" href="/assets/js/69.411058b6.js"><link rel="prefetch" href="/assets/js/7.12041889.js"><link rel="prefetch" href="/assets/js/70.316f37fd.js"><link rel="prefetch" href="/assets/js/71.7b1e8e79.js"><link rel="prefetch" href="/assets/js/72.44e79d39.js"><link rel="prefetch" href="/assets/js/73.8eeca473.js"><link rel="prefetch" href="/assets/js/74.0bb53483.js"><link rel="prefetch" href="/assets/js/75.c600e42f.js"><link rel="prefetch" href="/assets/js/76.08c8db66.js"><link rel="prefetch" href="/assets/js/77.5c3f11fa.js"><link rel="prefetch" href="/assets/js/78.bf1850e3.js"><link rel="prefetch" href="/assets/js/79.65f52781.js"><link rel="prefetch" href="/assets/js/8.19fb772b.js"><link rel="prefetch" href="/assets/js/80.346e5607.js"><link rel="prefetch" href="/assets/js/81.fa378849.js"><link rel="prefetch" href="/assets/js/82.917282bb.js"><link rel="prefetch" href="/assets/js/83.ab30e9c6.js"><link rel="prefetch" href="/assets/js/84.ffa19f6c.js"><link rel="prefetch" href="/assets/js/85.75e68c80.js"><link rel="prefetch" href="/assets/js/9.85c18bde.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">灰熊の博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/huixiongyu/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/huixiongyu/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/book/" aria-current="page" class="sidebar-link">阅读</a></li><li><a href="/book/plan-and-record.html" class="sidebar-link">阅读统计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/plan-and-record.html#_2021年已读" class="sidebar-link">2021年已读</a></li><li class="sidebar-sub-header"><a href="/book/plan-and-record.html#_2020已读" class="sidebar-link">2020已读</a></li></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/React/00-reactjs-practice.html" aria-current="page" class="active sidebar-link">《React.js实战》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第3章-react组件" class="sidebar-link">第3章-React组件</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第4章-漫谈react事件系统" class="sidebar-link">第4章-漫谈React事件系统</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第5章-深入react原理" class="sidebar-link">第5章-深入React原理</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第6章-react组件编写实战" class="sidebar-link">第6章-React组件编写实战</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第7章-redux数据管理" class="sidebar-link">第7章-Redux数据管理</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第8章-react架构" class="sidebar-link">第8章-React架构</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第9章-react服务端渲染" class="sidebar-link">第9章-React服务端渲染</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第10章-编写测试" class="sidebar-link">第10章 编写测试</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第11章-性能优化" class="sidebar-link">第11章-性能优化</a></li><li class="sidebar-sub-header"><a href="/book/React/00-reactjs-practice.html#第12章-hooks" class="sidebar-link">第12章-Hooks</a></li></ul></li><li><a href="/book/React/01-deep-learning-react-stack.html" class="sidebar-link">《深入React技术栈》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第1章-初入react世界" class="sidebar-link">第1章 初入React世界</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第2章-漫谈react" class="sidebar-link">第2章  漫谈React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#组件间通信" class="sidebar-link">组件间通信</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#组件间抽象" class="sidebar-link">组件间抽象</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#组件性能优化" class="sidebar-link">组件性能优化</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#动画" class="sidebar-link">动画</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#自动化测试" class="sidebar-link">自动化测试</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第3章-解读react源码" class="sidebar-link">第3章  解读React源码</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第4章-认识flux架构模式" class="sidebar-link">第4章  认识Flux架构模式</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第5章-深入redux应用架构" class="sidebar-link">第5章  深入Redux应用架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux简介" class="sidebar-link">Redux简介</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux-middleware" class="sidebar-link">Redux middleware</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux异步流" class="sidebar-link">Redux异步流</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux与路由" class="sidebar-link">Redux与路由</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux与组件" class="sidebar-link">Redux与组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第6章-redux高阶应用" class="sidebar-link">第6章  Redux高阶应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#高阶reducer" class="sidebar-link">高阶reducer</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux与表单" class="sidebar-link">Redux与表单</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux-crud实战" class="sidebar-link">Redux CRUD实战</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#redux性能优化" class="sidebar-link">Redux性能优化</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#解读redux" class="sidebar-link">解读Redux</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第7章-react服务端渲染" class="sidebar-link">第7章  React服务端渲染</a></li><li class="sidebar-sub-header"><a href="/book/React/01-deep-learning-react-stack.html#第8章-玩转react可视化" class="sidebar-link">第8章  玩转React可视化</a></li></ul></li><li><a href="/book/React/02-react-state-management-and-common-refator.html" class="sidebar-link">《React状态管理与同构实战》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第1章-react与前端" class="sidebar-link">第1章  React与前端</a></li><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第2章-深入浅出react" class="sidebar-link">第2章  深入浅出React</a></li><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第3章-redux应用架构基础" class="sidebar-link">第3章  Redux应用架构基础</a></li><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第4章-深入理解redux" class="sidebar-link">第4章  深入理解Redux</a></li><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第5章-揭秘react同构应用" class="sidebar-link">第5章  揭秘React同构应用</a></li><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第6章-深入理解react技术内幕与生态社区" class="sidebar-link">第6章  深入理解React技术内幕与生态社区</a></li><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第7章-单页应用代码分割" class="sidebar-link">第7章  单页应用代码分割</a></li><li class="sidebar-sub-header"><a href="/book/React/02-react-state-management-and-common-refator.html#第8章-react应用性能优化" class="sidebar-link">第8章  React应用性能优化</a></li></ul></li><li><a href="/book/React/03-React-Native-develop-practice.html" class="sidebar-link">《React Native移动开发实战》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第1章-react-native入门" class="sidebar-link">第1章  React Native入门</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第2章-react-native环境搭建" class="sidebar-link">第2章  React Native环境搭建</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第3章-react-native开发基础" class="sidebar-link">第3章 React Native开发基础</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第4章-常用组件介绍" class="sidebar-link">第4章  常用组件介绍</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第5章-常用api介绍" class="sidebar-link">第5章  常用API介绍</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第6章-组件封装" class="sidebar-link">第6章  组件封装</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第7章-网络与通信" class="sidebar-link">第7章  网络与通信</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第8章-混合开发高级篇" class="sidebar-link">第8章  混合开发高级篇</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第9章-热更新与打包部署" class="sidebar-link">第9章  热更新与打包部署</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第10章-基于lbs的天气预报应用开发" class="sidebar-link">第10章 基于LBS的天气预报应用开发</a></li><li class="sidebar-sub-header"><a href="/book/React/03-React-Native-develop-practice.html#第11章-o2o移动团购应用" class="sidebar-link">第11章  O2O移动团购应用</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Angular</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>沟通</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="《react-js实战》"><a href="#《react-js实战》" class="header-anchor">#</a> 《React.js实战》</h1> <p>这本书的大部分内容是比较基础的，不过Redux部分的解释和redux-thunk、redux-saga在自己使用过一遍后可以再细读一下作者所说的工作原理。另外服务端渲染很值得自己手动实现一遍。</p> <p>这本书的阅读体验不太好，代码应该给个Github仓库，不然查看来回折腾好久，微信读书上代码显示应该是扫描出来的，显示的区域有时大有时小，忒难受了。</p> <h2 id="第3章-react组件"><a href="#第3章-react组件" class="header-anchor">#</a> 第3章-React组件</h2> <p>通信可以简单地理解为组件之间的数据传递，如父子组件之间的通信、同级组件之间的通信等。</p> <p>props一般不允许更改，用static关键字来定义默认的props值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>static defaultProps = {
  name: '灰熊'
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>组件之间的通信：子组件可以通过this.props调用父节点的方法更新父组件的state值。</p> <ul><li>组件与组件之间有一个共同的父组件，可以通过父组件来通信，即一个子组件可以通过父组件的回调函数来改变props，从而改变另一个子组件的props。</li> <li>React提供了一种上下文方式，允许子组件可以直接访问祖先组件的属性和方法，从而使效率得到很大的提升。</li></ul> <p>生命周期：</p> <ul><li>挂载期</li> <li>更新期</li> <li>卸载期</li></ul> <p>挂载期依次触发：</p> <ol><li>constructor</li> <li>getInitialState（ES6中被废弃）</li> <li>getDefaultProps（ES6中被废弃）</li> <li>componentWillMount</li> <li>render</li> <li>componentDIdMount</li></ol> <p>组件更新过程：</p> <ul><li>componentWillReceiveProps：当父组件更新子组件的state时，该方法会被调用</li> <li>shouldComponentUpdate：该方法决定组件state或者props的改变是否需要重新渲染组件。</li> <li>componentWillUpdate：在组件接受新的props或者state时，即将进行重新渲染前调用该方法，和componentWillMount方法类似。</li> <li>componentDidUpdate：在组件重新渲染后调用该方法，和componentDidMount方法类似。</li></ul> <p><strong>在组件更新过程中，需要注意shouldComponentUpdate（）方法，如果该方法返回值为false时，组件将不进行重新渲染。该方法如果能用的恰到好处，就能够在React性能优化方面起到一定作用。</strong></p> <h2 id="第4章-漫谈react事件系统"><a href="#第4章-漫谈react事件系统" class="header-anchor">#</a> 第4章-漫谈React事件系统</h2> <p>事件循环原理</p> <p>事件捕获-&gt;事件冒泡</p> <p>this指向本组件，在构造方法中声明时，一定要用bind（）来绑定，传入this参数。</p> <h2 id="第5章-深入react原理"><a href="#第5章-深入react原理" class="header-anchor">#</a> 第5章-深入React原理</h2> <p>用JSX书写代码时，一定要记住＜script＞标签中的type为“text/babel”，因为JSX是浏览器不识别的，需要利用babel来对JSX进行编译，转为浏览器能够理解的JavaScript代码。</p> <p>JSX的样式使用，样式写在对象里，找一个括号括起来，样式变量名和属性名用驼峰。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>render() {
	const bgColor = {
		backgroundColor: &quot;red&quot;
    }
    return (
    	&lt;button style={bgColor}&gt;按钮&lt;/button&gt;
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>或者内联使用(第一个{}是JSX语法，第二个{}是对象)：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;button style={{backgroundColor: &quot;red&quot;}}&gt;按钮&lt;/button&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>如果遇到同一层级的子节点进行操作时，需要加上key属性来进行唯一区别，否则React会进行告警。key的唯一属性是避免删除、创建等重复操作，减少性能消耗。</strong></p> <p>setState（）方法为<strong>异步操作</strong>，实质上是通过一个队列机制来更新state。</p> <p>如果想在setState后立即得到最新的state值，可以通过函数来实现：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.setState({
	function(state) {
		return {
			count: state.count + 1
		}
	}
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="第6章-react组件编写实战"><a href="#第6章-react组件编写实战" class="header-anchor">#</a> 第6章-React组件编写实战</h2> <p>无状态组件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const HelloWorld = (props) =&gt; {
	return (
		&lt;div&gt;
			hello {props.name}
		&lt;/div&gt;
	)
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>所谓高阶函数，就是可以以一个函数为入参，返回结果也可能是函数的一个复杂函数。其实之前用到的setTimeout（）、Array.map（）都是高阶函数。</p> <p>高阶函数实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function add(x, y) {
	return x + y;
}
function higherFunc(x, y, f) {
	return f(x, y);
}
console.log(higherFunc(1, 2, add))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>高阶组件就是一个函数，其参数可以接收一个组件，然后可以返回一个组件</strong></p> <p>高阶组件的用法：</p> <ol><li>属性代理：比如修改原始组件的属性</li> <li>反向继承：基础组件成为父类，高阶组件成为子类</li></ol> <h2 id="第7章-redux数据管理"><a href="#第7章-redux数据管理" class="header-anchor">#</a> 第7章-Redux数据管理</h2> <p>Flux的四个概念：</p> <ul><li>Dispatcher：处理动作的一个分发器，是Flux应用程序中数据流的中心枢纽，主要任务是将收到的行为分发给Store。</li> <li>Store：对数据进行管理。</li> <li>View: React组件，主要负责View层。</li> <li>Action：提供给Dispatcher，传递数据给Store。</li></ul> <p>Flux结构图：</p> <p><img src="https://huixiong.oss-cn-beijing.aliyuncs.com/reading/Flux_2020-04-23_17-18-11.png" alt="flux"></p> <p><a href="https://mobx.js.org/README.html" target="_blank" rel="noopener noreferrer">mobx<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://huixiong.oss-cn-beijing.aliyuncs.com/reading/mobx_2020-04-23_17-24-47.png" alt="mobx"></p> <p>Redux吸收了Flux的优点，例如单向数据流、依赖变动等特性。但是，Redux还加入了一些新的特性，例如undo、redo等。同时，Redux保持轻量级API，便于实现更高层次的抽象。</p> <p>state本身是普通对象，没有修改器方法（setter方法），而state的修改是先通过发起action描述当前发生了什么，最终通过reducer函数把action和state串起来。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const action = {
	type: 'READ',
	msg: 'Keep on'
};
store.dispatch(action);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>reducer是纯函数，接收action和当前state作为参数，并返回一个新的state。</strong></p> <p>不要在reducer中直接修改传入的state，可以使用Object.assign（）或延展符号返回新的state。</p> <p>React-Redux提供connect方法，用于从UI组件生成容器组件。connect的意思就是将这两种组件连起来。</p> <p>connect方法接收两个参数：mapStateToProps和mapDispatchToProps。它们定义了UI组件的业务逻辑。前者负责输入逻辑，即将state映射到UI组件的参数（props）；后者负责输出逻辑，即将用户对UI组件的操作映射成action。</p> <p><img src="https://huixiong.oss-cn-beijing.aliyuncs.com/reading/Redux-workflow_2020-04-23_17-37-44.png" alt="redux-workflow"></p> <p>Redux中间件被设计成可组合的、会在dispatch方法之前调用的函数，例如redux-logger中间件</p> <p>Redux中间件使用：</p> <ul><li>redux-logger</li> <li>redux-thunk</li> <li>redux-saga</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>import thunk from 'redux-thunk'
import {createStore, applyMiddleware} from 'redux'

import counter from './reducers/counter'
let store = createStore(counter, applyMiddleware(thunk))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>redux-saga相当于在Redux原有的数据流中增加了一层监控，捕获监听到的action并进行处理之后，添加一个新的action到相应的reducer中执行处理流程。在redux-saga中的action与在redux中同步action的样式是相同的。</p> <p>redux-saga中定义了effect, effect本质就是一个特定的函数，返回的是纯文本对象。也就是说，通过effect函数会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作。redux-saga常见的effect有call、put、select、takeEvery、takeLatest、take、all等。</p> <p>redux-saga中使用call用来调用异步函数，将异步函数和函数参数作为call函数的参数传入，最终该函数返回一个对象。</p> <p><strong>Redux主要输出createStore、combineReducers、bindActionCreators、applyMiddleware、compose五个接口。</strong></p> <h2 id="第8章-react架构"><a href="#第8章-react架构" class="header-anchor">#</a> 第8章-React架构</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install -g create-react-app
create-react-app hello-world
cd hello-world
yarn start
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>文件：</p> <ul><li>components</li> <li>containers</li> <li>stores</li></ul> <p>CSS Modules</p> <ul><li>postcss-loader</li> <li>postcss-modules-values</li> <li>autoprefixer</li> <li>postcss-cssnext</li></ul> <p>Redux的创造者DanAbramov又补充了一句：“只有遇到React实在解决不了的问题，你才需要Redux。”从应用的角度考虑，Redux的适用场景是：多交互、多数据源。从组件的角度考虑，Redux适用于如下场景：</p> <ul><li>某个组件的状态需要共享。</li> <li>某个状态需要在任何地方都可以拿到。</li> <li>一个组件需要改变全局状态。</li> <li>一个组件需要改变另一个组件的状态。</li></ul> <p>react-router</p> <ul><li>Router</li> <li>Route</li> <li>hashHistory</li> <li>Link</li></ul> <h2 id="第9章-react服务端渲染"><a href="#第9章-react服务端渲染" class="header-anchor">#</a> 第9章-React服务端渲染</h2> <p>我们所说的服务端渲染是在现有架构不变的情况下，即后端依旧只是提供API服务，前端人员依旧通过异步请求数据，同时要达到传统多页应用的首屏加载性能，且进行SEO优化到搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</p> <p>客户端渲染执行的顺序是“下载JavaScript/CSS文件”→“请求数据”→“渲染页面”，三个过程都在客户端进行；服务端渲染执行的顺序是“请求数据”→“渲染页面”→“下载JavaScript/CSS文件”，其中请求数据和渲染页面在服务端进行，最后下载JavaScript/CSS文件在客户端进行。</p> <p><strong>相对于客户端渲染来说，服务端渲染的核心保障是首屏渲染。</strong></p> <p>做服务端渲染同构之前，一定要考虑到浏览器和服务器的环境差异，站在更高层面考虑。Next.js是时下非常流行的基于React的同构开发框架，提供了异步请求、样式、拆分文件打包的整体解决方案。</p> <h2 id="第10章-编写测试"><a href="#第10章-编写测试" class="header-anchor">#</a> 第10章 编写测试</h2> <p>测试驱动开发</p> <p>主流工具：Mocha、Jasmine、Karma、Jest等</p> <p><strong>现在主流推荐使用Jest作为测试框架、Enzyme作为React组件测试工具。</strong></p> <p>我们做单元测试也主要关注四个方面：<strong>组件渲染、状态变化、事件响应、网络请求。</strong></p> <p>使用Jest</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>yarn add jest --dev
npm install -D babel-jest babel-core babel-preset-env regenerator-runtime
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>创建index.test.js</p> <p>Jest</p> <ul><li>.not</li> <li>.toEqual()</li> <li>.toHaveLength 测试字符串和数组类型的长度是否满足预期</li> <li>.toThrow</li> <li>.toMatch传入一个正则表达式，它允许我们用来进行字符串类型的正则匹配。</li></ul> <p>使用snapshot测试组件UI</p> <p>propTypes检查类型错误</p> <p>TypeScript写React代码避免类型错误</p> <h2 id="第11章-性能优化"><a href="#第11章-性能优化" class="header-anchor">#</a> 第11章-性能优化</h2> <p>不要过早优化</p> <p>shouldComponentUpdate可以减少重绘，但是别到处都加shouldComponentUpdate，在简单组件上执行shouldComponentUpdate方法有时比仅渲染组件要耗时。</p> <p>Perf是React官方提供的性能分析工具。</p> <p>render里面尽量减少新建变量和bind函数，尽量减少所需传递参数的数量，尽可能地保持props和state简单和精简。</p> <p>shouldComponentUpdate默认每次更新的时候都要调用所用的生命周期函数，包括render函数，重新渲染。</p> <p><strong>一些细节的优化点：</strong></p> <ul><li>慎用｛...this.props｝，只传递component需要的props，传得太多或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此慎用spread attributes（＜Component｛...props｝/＞））。</li> <li>::this.handleChange（），将该方法的bind于constructor中进行定义，即this.handleChange.bind（this, id）。</li> <li>复杂的页面不要全部写在一个组件里面，尽量拆分。</li> <li>尽量使用const element。·map中需要添加key，并且key不要使用index。</li> <li>尽量少用setTimeout或不可控的refs、DOM操作。</li> <li>props和state的数据尽可能简单明了，扁平化。</li> <li>使用return null而不是CSS的display：none来控制节点的显示隐藏，保证同一时间页面的DOM节点尽可能少。</li></ul> <p>immutable使用了StructuralSharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。</p> <p>在React开发中，频繁操作state对象或是store，配合ImmutableJS会更快、更安全、更方便。</p> <ul><li>immutable降低了Mutable带来的复杂度</li> <li>节省内存</li> <li>并发安全</li> <li>拥抱函数式编程</li></ul> <p>immutable几个重要的API</p> <ul><li>fromJS（）</li> <li>toJS（）</li> <li>Map</li> <li>List</li></ul> <h2 id="第12章-hooks"><a href="#第12章-hooks" class="header-anchor">#</a> 第12章-Hooks</h2> <p>Hooks提供的API可以大幅减少React函数组件的代码量.</p> <ul><li>useState</li> <li>useEffect</li> <li>useReducer</li> <li>useCallback</li> <li>useMemo</li> <li>useContext</li> <li>useRef</li> <li>useImperativeMethods</li> <li>useMutationEffect</li> <li>useLayoutEffect</li></ul> <p>需要注意的是，只能在顶层代码（Top Level）中调用Hooks，不能在循环或判断语句等里面调用，这是为了让Hooks在每次渲染的时候都会按照相同的顺序调用，因为useState需要依赖参照第一次渲染的调用顺序来匹配对应的state，否则useState会无法正确返回对应的state。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">12/15/2021, 3:52:44 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book/Vue/01-vue-up-and-running.html" class="prev">
        《Vue.js快跑》
      </a></span> <span class="next"><a href="/book/React/01-deep-learning-react-stack.html">
        《深入React技术栈》
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5be59e6d.js" defer></script><script src="/assets/js/2.9b8ab7f9.js" defer></script><script src="/assets/js/45.36f736c0.js" defer></script>
  </body>
</html>
